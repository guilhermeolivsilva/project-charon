"""Implement a lexer for the Tiny C compiler."""


class Lexer:
    types = {
        "int": "INT_TYPE",
        "float": "FLOAT_TYPE",
        "long": "LONG_TYPE"
    }

    conditionals = {
        "do": "DO_SYM",
        "while": "WHILE_SYM",
        "if": "IF_SYM",
        "else": "ELSE_SYM"
    }

    symbols = {
        "{": "LCBRA",
        "}": "RCBRA",
        "[": "LBRA",
        "]": "RBRA",
        "(": "LPAR",
        ")": "RPAR",
        ";": "SEMI",
        ".": "DOT"
    }

    operators = {
        "=": "ASSIGN",
        "+": "PLUS",
        "-": "MINUS",
        "*": "MULT",
        "/": "DIV",
        "<": "LESS",
        ">": "GREATER",
        "<<": "LSHIFT",
        ">>": "RSHIFT",
        "&": "BITAND",
        "|": "BITOR",
        "==": "EQUAL"
    }

    reserved_words = {
        **types,
        **conditionals,
        **symbols,
        **operators,

        # Additional reserved words that are not in previous categories
        "struct": "STRUCT_DEF",
        "return": "RET_SYM"
    }

    def __init__(self, source_code: str) -> None:
        self.source_code: str = source_code
        self.scopes: dict[str, dict] = {}

    def parse_source_code(self) -> dict:
        """
        Parse the source code and generate tokens from it.

        Returns
        -------
        parsed_source_code : dict
            TODO
        """

        # TODO

    def split_source(self) -> list[str]:
        """
        Split the source code in individual words and symbols.

        This method is intended to handle reserved words, spaces, line breaks
        and other style-related issues.

        Returns
        -------
        tokenized_source_code : list of str
            A list of words and individual characters obtained from the source
            code.
        """

        # Remove line breaks
        source_code = self.source_code.replace("\n", "")

        # Collapse `long int` to just `long`
        source_code = source_code.replace("long int", "long")

        # Replace commas with spaces
        source_code = source_code.replace(",", " ")

        # Tweak braces, parenthesis and semicolons before splitting the string
        # by blank spaces
        tokens_to_tweak = ["(", ")", "{", "}", ";", "[", "]"]
        for token in tokens_to_tweak:
            source_code = source_code.replace(token, f" {token} ")

        # Split the code word by word (or character by character)
        source_code = source_code.split(" ")

        # Remove empty tokens
        tokenized_source = list(
            filter(lambda curr_token: curr_token if len(curr_token) > 0 else None, source_code)
        )

        return tokenized_source
    
    def annotate_source(self, symbol_collection: list[str]) -> list[str]:
        """
        Annotate the variables, constants and functions of the source.

        Parameters
        ----------
        symbol_collection : list of str
            The collection of symbols generated by the `split_source` method.

        Returns
        -------
        annotated_source : list of str
            The `symbol_collection`, but with preffixes that identify
            variable and function declarations/usage, and constants.
        """

        ...

    def _annotate_constants(self, symbol_collection: list[str]) -> list[str]:
        """
        Annotate constants with types.

        Parameters
        ----------
        symbol_collection : list of str
            The collection of symbols generated by the `split_source` method.

        Returns
        -------
        symbol_collection : list of str
            The `symbol_collection` with annotated constants.
        """

        for idx, token in enumerate(symbol_collection):
            try:
                _ = int(token)
                symbol_collection[idx] = "int_cst_" + token
                continue

            except ValueError:
                pass

            try:
                _ = float(token)
                symbol_collection[idx] = "float_cst_" + token
                continue

            except ValueError:
                pass

        return symbol_collection
    
    def _annotate_functions(self, symbol_collection: list[str]) -> list[str]:
        """
        Annotate functions with the preffixes for definitions and calls.

        Parameters
        ----------
        symbol_collection : list of str
            The collection of symbols generated by the `split_source` method.

        Returns
        -------
        symbol_collection : list of str
            The `symbol_collection` with annotated variables.

        Raises
        ------
        SyntaxError
        """

        declared_main = False

        for idx, token in enumerate(symbol_collection):
            # Skip `word` if it is a known symbol/reserved word or an annotated
            # constant, skip it
            already_handled = (
                (token in self.reserved_words)
                or ("cst" in token)
            )
            if already_handled:
                continue

            succeeded_by_left_parenthesis = symbol_collection[idx + 1] == "("

            # We assume that all functions references (either definition or
            # callings) are `<func_name> <(> ...`. Then, if the next symbol is
            # not a left parenthesis (`(`), it must not be a function.
            if not succeeded_by_left_parenthesis:
                continue

            # If followed by left parenthesis, decide whether it is a function
            # definition (not in `self.functions`, and preceeded by a type),
            # call (in `self.functions`, and not preceeded by a type), or a
            # syntax error (in `self.functions`, and preceeded by a type).
            preceeded_by_type = symbol_collection[idx - 1] in self.types
            function_is_known = token in self.functions

            # It is a definition
            if preceeded_by_type and not function_is_known:
                function_type = symbol_collection[idx - 1]
                preffix = "func_def_"

                # Save the indices of the first and last instruction of the
                # function for scope handling
                start_idx, end_idx = _get_function_limits(
                    symbol_collection=symbol_collection,
                    function_idx=idx
                )
                parameters = self._extract_parameters(
                    symbol_collection=symbol_collection,
                    function_idx=idx
                )

                self.functions[token] = {
                    "type": function_type,
                    "start_idx": start_idx,
                    "end_idx": end_idx,
                    "parameters": parameters
                }

                # Set the `declared_main` flag
                declared_main = token == "main"

            # It is a call
            elif not preceeded_by_type and function_is_known:
                preffix = "func_call_"

            # It is a redefinition
            elif preceeded_by_type and function_is_known:
                err_msg = f"Redefinition of function '{token}'"
                raise SyntaxError(err_msg)
            
            symbol_collection[idx] = preffix + token
            continue

        if not declared_main:
            err_msg = "'main' function has not been declared."
            raise SyntaxError(err_msg)

        return symbol_collection

    def _extract_parameters(
        self,
        symbol_collection: list[str],
        function_idx: int
    ) -> list[tuple[str, str]]:
        """
        Extract the parameters from a function.

        The extracted parameters are returned as a list of (param_type, param_name)
        tuples.

        Parameters
        ----------
        symbol_collection : list of str
            The collection of symbols generated by the `split_source` method.
        function_idx : int
            The index of the function name in the `symbol_collection` list.

        Returns
        -------
        parameters : list of (param_type, param_name) tuples
            The list of function parameters. If the function take no parameters,
            return an empty list.
        """
        
        # Align with the index of the left parenthesis (add 1 to offset).
        curr_idx = function_idx + 1
        parameters = []

        try:
            while symbol_collection[curr_idx] != ")":
                curr_token = symbol_collection[curr_idx]

                if curr_token == "(":
                    curr_idx += 1

                elif curr_token == ")":
                    break

                else:
                    param_type = curr_token
                    param_name = symbol_collection[curr_idx + 1]

                    if param_type not in [*self.types, *self.structs]:
                        function_name = symbol_collection[function_idx]
                        err_msg = (
                            f"Unknown type '{param_type}' in definition of "
                            + f"function '{function_name}'"
                        )
                        raise SyntaxError(err_msg)

                    parameters.append((param_type, param_name))
                    curr_idx += 2

        except IndexError:
            function_name = symbol_collection[function_idx]
            err_msg = f"Function '{function_name}' has malformed parameters."
            raise SyntaxError(err_msg)

        return parameters

    def _handle_struct(
        self,
        symbol_collection: list[str],
        struct_idx: int
    ) -> dict[str, dict]:
        """
        Handle a struct definition.

        The extracted attributes are returned as a list of (param_type, param_name)
        tuples. This method also returns the type name of the struct.

        Parameters
        ----------
        symbol_collection : list of str
            The collection of symbols generated by the `split_source` method.
        struct_idx : int
            The index of the `struct` keyword in the `symbol_collection` list.

        Returns
        -------
        struct_metadata : dict
            A dictionary with the following content:
            {
                "struct_name": name of the structure,
                "attributes": list of (`attr_type`, `attr_name`) tuples.
            }

        Raises
        ------
        SyntaxError
            Raised if
             - the struct is named after a reserved word or symbol;
             - any attributes are named after a reserved word or symbol;
             - an attribute is redefined within the struct;
             - the struct uses an unknown type for one of its attributes.
        """

        attributes: list[tuple[str, str]] = []
        idx: int = 0

        # Offset of two tokens: `struct` and `{`
        struct_start: int = struct_idx + 2

        subset: list[str] = symbol_collection[struct_start:]

        # Extract
        while idx < len(subset):
            if subset[idx] == "}":
                break

            attr_type, attr_name = subset[idx:idx + 2]
            attributes.append((attr_type, attr_name))

            # Expected format: `attr_type` `attr_name` `;`. Thus, offset 
            # 3 tokens
            idx += 3

        struct_name = subset[idx + 1]

        # Validate
        # 1. Check if the struct has a valid name
        if struct_name in self.reserved_words:
            err_msg = f"Invalid struct name '{struct_name}'"
            raise SyntaxError(err_msg)

        unique_attr_names = set()
        for attr_type, attr_name in attributes:

            # 2. Check if all the types are valid
            if attr_type not in [*self.types, *self.structs]:
                err_msg = (
                    f"Unknown type '{attr_type}' of struct attribute"
                    f" '{attr_name}'"
                )
                raise SyntaxError(err_msg)
            
            # 3. Check if there are no attributes with duplicate names
            if attr_name in unique_attr_names:
                err_msg = (
                    f"Redefinition of attribute '{attr_name}' in struct"
                    f" '{struct_name}'"
                )
                raise SyntaxError(err_msg)
            else:
                unique_attr_names.add(attr_name)

            # 4. Check if there are attributes named after reserved words
            if attr_name in self.reserved_words:
                err_msg = (
                    f"Invalid name of attribute '{attr_name}' in struct"
                    f"' {struct_name}'"
                )
                raise SyntaxError(err_msg)

        return {
            "struct_name": struct_name,
            "attributes": attributes
        }

def _get_function_limits(
    symbol_collection: list[str],
    function_idx: int
) -> tuple[int, int]:
    """
    Get the limits of the function in terms of indices.

    The function limits are refer to the index of the first and last tokens
    within the function scope in the `symbol_collection`.

    Parameters
    ----------
    symbol_collection : list of str
        The collection of symbols generated by the `split_source` method.
    function_idx : int
        The index of the function name in the `symbol_collection` list.

    Returns
    -------
    start : int
        The index, in the `symbol_collection`, of the first token within the
        function scope.
    end : int
        The index, in the `symbol_collection`, of the last token within the
        function scope.
    """

    brackets_stack = []
    function_begun = False
    start, end = (None, None)

    for relative_idx, token in enumerate(symbol_collection[function_idx:]):
        idx = relative_idx + function_idx

        if token == "{" and not start:
            start = idx + 1
            function_begun = True
            brackets_stack.append(1)

        elif token == "}":
            brackets_stack.pop()

        if not brackets_stack and function_begun:
            end = idx - 1
            break

    return (start, end)

"""Implement a virtual machine that computes generated code."""

from typing import Union


class VirtualMachine:
    """
    Virtual Machine that computes instructions from the `CodeGenerator`.

    Parameters
    ----------
    program : dict[str, Union[list, dict]]
        The program generated by the `CodeGenerator.generate_code` method.
    stack_size : int, optional (default = 1000)
        The number of positions the stack should have.
    memory_size : int, optional (default = 1024)
        The memory size, in bytes, to use.
    """

    def __init__(
        self,
        program: dict[str, Union[list, dict]],
        stack_size: int = 1000,
        memory_size: int = 1024,
    ) -> None:
        self.program: dict[str, Union[list, dict]] = program
        self.stack: list[int, float] = [None for _ in range(0, stack_size)]
        self.memory: dict[hex, hex] = {
            hex(_byte): None
            for _byte in range(memory_size)
        }
        self.registers: dict = {}

        # Pointers
        self.stack_pointer: int = 0
        self.program_counter: int = 0

    def __str__(self) -> str:
        """
        Generate a string representation of the VirtualMachine object.

        Returns
        -------
        : str
            The string representation.
        """

        ...

    def print(self) -> None:
        """Print this VirtualMachine object."""

        print(self)

    def run(self) -> None:
        """Run the program on the virtual machine."""

        ...

    def ADD(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `ADD` bytecode.

        This method handles the addition between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def AND(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `AND` bytecode.

        This method handles the "logical and" operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def ALLOC(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `ALLOC` bytecode.

        This method allocates memory for a variable.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def BITAND(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `BITAND` bytecode.

        This method handles the bit-wise "and" operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def BITOR(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `BITOR` bytecode.

        This method handles the bit-wise "or" operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def CALL(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `CALL` bytecode.

        This method handles the call to a function.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def CONSTANT(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `CONSTANT` bytecode.

        This method saves the constant at some register.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def DIV(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `DIV` bytecode.

        This method handles the division between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def ELEMENT_PTR(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `ELEMENT_PTR` bytecode.

        This method gets the pointer of an array or struct element.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def EQ(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `EQ` bytecode.

        This method handles the "is equal" comparison between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def FADD(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `FADD` bytecode.

        This method handles the addition between two floating point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def FAND(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `FAND` bytecode.

        This method handles the "logical and" operation between two floating
        point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def FDIV(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `FDIV` bytecode.

        This method handles the division between two floating point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def FEQ(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `FEQ` bytecode.

        This method handles the "is equal" comparison between two floating point
        numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def FGT(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `FGT` bytecode.

        This method handles the "greater than" comparison between two floating
        point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def FLT(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `FLT` bytecode.

        This method handles the "less than" comparison between two floating
        point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def FMULT(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `FMULT` bytecode.

        This method handles the multiplication between two floating point
        numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def FOR(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `FOR` bytecode.

        This method handles the "logical or" operation between two floating
        point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def FSUB(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `FSUB` bytecode.

        This method handles the subtraction between two floating point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def GT(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `GT` bytecode.

        This method handles the "greater than" comparison between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def HALT(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `HALT` bytecode.

        This method handles the end of the execution of a program.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def JMP(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `JMP` bytecode.

        This method handles unconditional jumps.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def JNZ(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `JNZ` bytecode.

        This method handles conditional jumps: if the evaluated value is not
        zero, jump some amount of instructions.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def JZ(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `JZ` bytecode.

        This method handles conditional jumps: if the evaluated value is zero,
        jump some amount of instructions.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def LSHIFT(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `LSHIFT` bytecode.

        This method handles the left bit-shift operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def LT(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `LT` bytecode.

        This method handles the "less than" comparison between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def MULT(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `MULT` bytecode.

        This method handles the multiplication between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def OR(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `OR` bytecode.

        This method handles the "logical or" operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def RET(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `RET` bytecode.

        This method handles the `return` statement of a function.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def RSHIFT(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `RSHIFT` bytecode.

        This method handles the right bit-shift operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def STORE(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `STORE` bytecode.

        This method stores some value in a variable.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def SUB(self, bytecode: dict[str, dict]) -> None:
        """
        Handle a `SUB` bytecode.

        This method handles the subtraction between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

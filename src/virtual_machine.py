"""Implement a virtual machine that computes generated code."""

from typing import Union


class VirtualMachine:
    """
    Virtual Machine that computes instructions from the `CodeGenerator`.

    Parameters
    ----------
    program : dict[str, Union[list, dict]]
        The program generated by the `CodeGenerator.generate_code` method.
    stack_size : int, optional (default = 1024)
        The stack size, in bytes, to use.
    """

    def __init__(
        self,
        program: dict[str, Union[list, dict]],
        stack_size: int = 1024,
    ) -> None:
        self.program: dict[str, Union[list, dict]] = program
        self.stack: dict[hex, hex] = {
            hex(_byte): None
            for _byte in range(stack_size)
        }
        self.registers: list[int, float] = []

        # Pointers
        self.stack_pointer: int = 0
        self.program_counter: int = 0

    def __str__(self) -> str:
        """
        Generate a string representation of the VirtualMachine object.

        Returns
        -------
        : str
            The string representation.
        """

        ...

    def print(self) -> None:
        """Print this VirtualMachine object."""

        print(self)

    def run(self) -> None:
        """Run the program on the virtual machine."""

        ...

    def ADD(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `ADD` bytecode.

        This method handles the addition between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs + rhs

    def AND(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `AND` bytecode.

        This method handles the "logical and" operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.

        Notes
        -----
        This method writes `1` in the target `register` if Python's evaluation
        of `lhs and rhs` results in anything different from `0`. This is due to
        the fact that the language does not support boolean literals (`True` and
        `False`).
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = (
            1 if (lhs and rhs) > 0 else 0
        )

    def ALLOC(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `ALLOC` bytecode.

        This method allocates memory for a variable.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def BITAND(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `BITAND` bytecode.

        This method handles the bit-wise "and" operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs & rhs

    def BITOR(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `BITOR` bytecode.

        This method handles the bit-wise "or" operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs | rhs

    def CALL(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `CALL` bytecode.

        This method handles the call to a function.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def CONSTANT(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `CONSTANT` bytecode.

        This method saves the constant at some register.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def DIV(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `DIV` bytecode.

        This method handles the division between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs / rhs

    def ELEMENT_PTR(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `ELEMENT_PTR` bytecode.

        This method gets the pointer of an array or struct element.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def EQ(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `EQ` bytecode.

        This method handles the "is equal" comparison between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.

        Notes
        -----
        This method writes `1` in the target `register` if the expression
        evaluates to `True`, and `0` other wise. This is due to the fact that
        the language does not support boolean literals (`True` and `False`).
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = int(lhs == rhs)

    def FADD(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `FADD` bytecode.

        This method handles the addition between two floating point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs + rhs

    def FAND(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `FAND` bytecode.

        This method handles the "logical and" operation between two floating
        point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.

        Notes
        -----
        This method writes `1` in the target `register` if Python's evaluation
        of `lhs and rhs` results in anything different from `0`. This is due to
        the fact that the language does not support boolean literals (`True` and
        `False`).
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = (
            1 if (lhs and rhs) > 0 else 0
        )

    def FDIV(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `FDIV` bytecode.

        This method handles the division between two floating point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs / rhs

    def FEQ(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `FEQ` bytecode.

        This method handles the "is equal" comparison between two floating point
        numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.

        Notes
        -----
        This method writes `1` in the target `register` if the expression
        evaluates to `True`, and `0` other wise. This is due to the fact that
        the language does not support boolean literals (`True` and `False`).
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = int(lhs == rhs)

    def FGT(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `FGT` bytecode.

        This method handles the "greater than" comparison between two floating
        point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.

        Notes
        -----
        This method writes `1` in the target `register` if the expression
        evaluates to `True`, and `0` other wise. This is due to the fact that
        the language does not support boolean literals (`True` and `False`).
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = int(lhs > rhs)

    def FLT(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `FLT` bytecode.

        This method handles the "less than" comparison between two floating
        point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.

        Notes
        -----
        This method writes `1` in the target `register` if the expression
        evaluates to `True`, and `0` other wise. This is due to the fact that
        the language does not support boolean literals (`True` and `False`).
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = int(lhs < rhs)

    def FMULT(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `FMULT` bytecode.

        This method handles the multiplication between two floating point
        numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs * rhs

    def FOR(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `FOR` bytecode.

        This method handles the "logical or" operation between two floating
        point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.

        Notes
        -----
        This method writes `1` in the target `register` if Python's evaluation
        of `lhs or rhs` results in anything different from `0`. This is due to
        the fact that the language does not support boolean literals (`True` and
        `False`).
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = (
            1 if (lhs or rhs) > 0 else 0
        )

    def FSUB(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `FSUB` bytecode.

        This method handles the subtraction between two floating point numbers.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs - rhs

    def GT(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `GT` bytecode.

        This method handles the "greater than" comparison between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.

        Notes
        -----
        This method writes `1` in the target `register` if the expression
        evaluates to `True`, and `0` other wise. This is due to the fact that
        the language does not support boolean literals (`True` and `False`).
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = int(lhs > rhs)

    def HALT(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `HALT` bytecode.

        This method handles the end of the execution of a program.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def JMP(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `JMP` bytecode.

        This method handles unconditional jumps.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def JNZ(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `JNZ` bytecode.

        This method handles conditional jumps: if the evaluated value is not
        zero, jump some amount of instructions.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def JZ(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `JZ` bytecode.

        This method handles conditional jumps: if the evaluated value is zero,
        jump some amount of instructions.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def LSHIFT(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `LSHIFT` bytecode.

        This method handles the left bit-shift operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs << rhs

    def LT(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `LT` bytecode.

        This method handles the "less than" comparison between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.

        Notes
        -----
        This method writes `1` in the target `register` if the expression
        evaluates to `True`, and `0` other wise. This is due to the fact that
        the language does not support boolean literals (`True` and `False`).
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = int(lhs < rhs)

    def MULT(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `MULT` bytecode.

        This method handles the multiplication between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs * rhs

    def OR(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `OR` bytecode.

        This method handles the "logical or" operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.

        Notes
        -----
        This method writes `1` in the target `register` if Python's evaluation
        of `lhs or rhs` results in anything different from `0`. This is due to
        the fact that the language does not support boolean literals (`True` and
        `False`).
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = (
            1 if (lhs or rhs) > 0 else 0
        )

    def RET(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `RET` bytecode.

        This method handles the `return` statement of a function.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def RSHIFT(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `RSHIFT` bytecode.

        This method handles the right bit-shift operation between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs >> rhs

    def STORE(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `STORE` bytecode.

        This method stores some value in a variable.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        ...

    def SUB(self, instruction_metadata: dict[str, dict]) -> None:
        """
        Handle a `SUB` bytecode.

        This method handles the subtraction between two integers.

        `short`-typed values will also use this method.

        Parameters
        ----------
        bytecode : dict[str, dict]
            The bytecode containing the instruction and its metadata.
        """

        lhs = self.registers[instruction_metadata.get("lhs_register")]
        rhs = self.registers[instruction_metadata.get("rhs_register")]

        self.registers[instruction_metadata.get("register")] = lhs - rhs

"""Base class for AST Nodes classes (e.g., VAR, CST etc.)."""

from typing import Union

from src.utils import get_certificate_symbol


class Node:
    """
    Implement a Node for the AST.

    Parameters
    ----------
    value : str, int, float, or None, optional (default = None)
        The value the Node holds, if any. Defaults to None.
    type : str or None (optional, default = None)
        The type of the Node, if any. Defaults to None.
    uses_register : bool (optional, default = False)
        Whether the code generated by this Node will use a register (i.e.,
        whether the exported code should have the `register` field).
    """

    def __init__(
        self,
        value: Union[int, str, float, None] = None,
        type: Union[str, None] = None,
        uses_register: bool = True
    ) -> None:
        self.value: Union[int, str, float, None] = value
        self.type: Union[str, None] = type
        self.certificate_label: str = None
        self.uses_register: bool = uses_register

        # Each `Node` specialization must set its own `instruction` and
        # `symbol`.
        self.instruction: str = None
        self.symbol: str = get_certificate_symbol(self)

    def __eq__(self, other: "Node") -> bool:
        """
        Implement the equality comparison between Nodes.

        Parameters
        ----------
        other : Node
            The right hand side Node of the comparison.

        Returns
        -------
        is_equal : bool
            `True` if all the attributes are equal, `False` otherwise.
        """

        is_equal = (
            self.value == other.value
            and type(self) is type(other)
        )

        return is_equal

    def __str__(self) -> str:
        """
        Implement a string representation of a Node object.

        This method is internally invoked when using `print(node_obj)`.

        Returns
        -------
        _str : str
            The string representation of a Node object.
        """

        _str = ""

        if self.value is not None:
            _str += f"Value: {self.value}, "

        _str += f"Kind: {type(self).__name__}"

        if self.type is not None:
            _str += f", Type: {self.type}"

        if self.certificate_label is not None:
            _str += f", Certificate Label: {self.certificate_label}"

        return _str
    
    def get_value(self) -> Union[int, str, float, None]:
        """
        Get the value of this Node.

        Returns
        -------
        : Union[int, str, float, None]
            The value of this Node.
        """

        return self.value
    
    def get_type(self) -> Union[str, None]:
        """
        Get the type of this Node.

        Returns
        -------
        : Union[str, None]
            The type of the Node.
        """

        return self.type

    def get_certificate_label(self) -> list[str]:
        """
        Get the contents of `certificate_label`.

        Returns
        -------
        : list of str
            A list containing the certificate label of the `Node`.

        Notes
        -----
        This method returns a list, rather than the string itself, in order to
        allow returning multiple labels when nodes have children. Thus,
        subclasses should return a composition of lists.
        """

        return [self.certificate_label]

    def print(self, indent: int = 0) -> None:
        """
        Print the string representation of `self`.

        The printed text is indented according with the optional `indent`
        paremeter.

        Parameters
        ----------
        indent : int (optional, default = 0)
            The number of left padding spaces to indent.
        """

        print("  " * indent + str(self))

    def generate_code(self, register: int) -> tuple[
        int,
        list[dict[str, Union[int, str]]]
    ]:
        """
        Generate the code associated with this `Node`.

        The generated code consists of a dictionary containing the relevant
        `Node` data for the code to run -- namely, the `instruction`, and the
        `value`.

        Notice that some `Nodes` may rewrite this method in order to deal
        with special attributes -- such as the `Operation` nodes, that must
        handle its children nodes.

        This method takes an integer as its parameter in order to allocate a
        register to support the generated code. It also returns an integer --
        usually `register + 1` -- for it to be passed to the next Node.

        Parameters
        ----------
        register : int
            The number of the register to be used by the code generated by this
            Node.

        Returns
        -------
        register : int
            The number of the next register available.
        code_metadata : list of dict
            Return a list of dictionaries containing code metadata: the register
            to be used, the related `instruction` and its metadata.

        Notes
        -----
        This method returns a `list` rather than only the `code_metadata` in
        order to standardize the return type as some subclasses might have to
        generate code using not only the node itself, but its children, too.
        """

        code_metadata = {
            "instruction": self.instruction,
            "metadata": {}
        }

        if self.uses_register:
            code_metadata["metadata"]["register"] = register
            register += 1

        if self.value is not None:
            code_metadata["metadata"]["value"] = self.value

        return register, [code_metadata]

    def certificate(self) -> None:
        """Compute the certificate of the current `Node`, and set this attribute."""

        self.certificate_label = f"({self.symbol})"

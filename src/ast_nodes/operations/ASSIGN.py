"""Representation of ASSIGN nodes for the Abstract Syntax Tree."""

from typing import Union

from typing_extensions import override

from src.ast_nodes.node import Node
from src.ast_nodes.variables.VAR import VAR
from src.ast_nodes.variables.ELEMENT_ACCESS import ELEMENT_ACCESS
from src.ast_nodes.operations.operation import Operation


class ASSIGN(Operation):
    """
    Implement the representation of a attribution operation for the AST.

    Parameters
    ----------
    lhs : Node
        The node representation of the variable to attribute to.
    rhs : Node
        The node representation of the expression to be attributed to `lhs`.

    Raises
    ------
    TypeError
        Raised if the `lhs` parameter is not a `VAR` or `ELEMENT_ACCESS` nodes.
    """

    @override
    def __init__(self, lhs: Node, rhs: Node) -> None:
        if not isinstance(lhs, (VAR, ELEMENT_ACCESS)):
            raise TypeError("Left-hand side of ASSIGN operation is not a Variable.")

        super().__init__(lhs=lhs, rhs=rhs, type=lhs.type)

        self.instruction: str = "STORE"

    @override
    def generate_code(
        self, register: int, environment: dict[str, dict[int, str]]
    ) -> tuple[
        list[dict[str, Union[int, str, float]]],
        int,
        dict[int, str]
    ]:
        """
        Generate the code associated with this `ASSIGN` operation.

        For this node specialization, generate code from the left and right
        hand sides nodes first, and then from the node itself.

        The `ASSIGN` operation does not need a register for itself. Thus, after
        generating the code, we "undo" the "register allocation" and decrement
        the `register` value to be returned.

        Not pretty. But works.

        Parameters
        ----------
        register : int
            The number of the register to be used by the code generated by this
            Node.
        environment : dict[int, str]
            The compiler's environment, that maps variables IDs to memory
            addresses and function IDs to instructions indices.

        Returns
        -------
        code : list of dict
            Return a list of dictionaries containing code metadata: the register
            to be used, the related `instruction` and its metadata.
        register : int
            The number of the next register available.
        environment : dict[int, str]
            The updated {var_id: address} environment mapping.
        """

        (
            operation_code,
            register,
            environment
        ) = super().generate_code(
            register=register,
            environment=environment
        )

        # Adjust the field names of the `STORE` instruction
        operation_code[-1]["metadata"]["register"] = operation_code[-1]["metadata"][
            "lhs_register"
        ]
        operation_code[-1]["metadata"]["value"] = operation_code[-1]["metadata"][
            "rhs_register"
        ]

        del operation_code[-1]["metadata"]["lhs_register"]
        del operation_code[-1]["metadata"]["rhs_register"]

        return operation_code, register, environment

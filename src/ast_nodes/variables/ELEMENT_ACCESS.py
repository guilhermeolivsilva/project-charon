"""Representation of ELEMENT_ACCESS nodes for the Abstract Syntax Tree."""

from typing import Union

from typing_extensions import override

from src.ast_nodes.node import Node
from src.ast_nodes.variables.VAR import VAR
from src.ast_nodes.basic.CST import CST
from src.utils import (
    builtin_types,
    get_certificate_symbol,
    next_prime,
    TYPE_SYMBOLS_MAP,
)


class ELEMENT_ACCESS(Node):
    """
    Implement the representation of an elemment access node for the AST.

    An element access is used within the context of arrays (indexes), and
    structs (attributes).

    This Node typechecks, and raises a `TypeError` if `variable` does not have a
    `length` attribute -- i.e., is not an array or struct.

    Parameters
    ----------
    variable : str
        The variable whose element is being accessed.
    element : int
        The index of the element being accessed.

    Raises
    ------
    TypeError
        - Raised if `variable` is not an array or a struct.
    """

    @override
    def __init__(self, variable: VAR, element: Union[CST, VAR]) -> None:
        variable_metadata = variable.get_metadata()

        self.is_array = "length" in variable_metadata
        self.is_struct = "attributes" in variable_metadata

        if not (self.is_array or self.is_struct):
            raise TypeError(
                "Trying to access an element from variable that is not an array"
                " nor struct."
            )
        
        if self.is_array and self.is_struct:
            raise TypeError(
                "Malformed `ELEMENT_ACCESS` node: can't tell if it is an array"
                " or struct."
            )

        super().__init__()

        self.variable: VAR = variable
        self.element: Union[CST, VAR] = element
        self.type: str = self._compute_element_type()

        # Handle the `instruction` and `symbol`. This defaults to the `read`
        # case, but can be changed by the AST as it is built
        self.add_context(context={"context": "read"})

    @override
    def print(self, indent: int = 0) -> None:
        """
        Print the string representation of this `ELEMENT_ACCESS`.

        The node itself is aligned with `indent`, and its children (the
        variable and the element index) are padded with an additional left
        space.

        Parameters
        ----------
        indent : int (optional, default = 0)
            The number of left padding spaces to indent.
        """

        super().print(indent)
        self.variable.print(indent=indent + 1)
        self.element.print(indent=indent + 1)

    @override
    def generate_code(
        self, register: int, environment: dict[str, dict[int, str]]
    ) -> tuple[
        list[dict[str, Union[int, str, float]]],
        int,
        dict[int, str]
    ]:
        """
        Generate the code associated with this `ELEMENT_ACCESS`.

        For this node specialization, generate code from `variable` and
        `element` children nodes first, respectively, and then from the
        `ELEMENT_ACCESS` itself.

        Parameters
        ----------
        register : int
            The number of the register to be used by the code generated by this
            Node.
        environment : dict[int, str]
            The compiler's environment, that maps variables IDs to memory
            addresses and function IDs to instructions indices.

        Returns
        -------
        code : list of dict
            Return a list of dictionaries containing code metadata: the register
            to be used, the related `instruction` and its metadata.
        register : int
            The number of the next register available.
        environment : dict[int, str]
            The updated {var_id: address} environment mapping.
        """

        code: list[dict[str, Union[int, str]]] = []

        (
            variable_code,
            register,
            environment
        ) = self.variable.generate_code(
            register=register,
            environment=environment
        )
        variable_address_register = register - 1

        # Eliminate the `LOAD` from the variable code generation, as it won't
        # be needed.
        if self.context.get("context") == "read":
            variable_address_register -= 1
            variable_code.pop()

        code.extend(variable_code)

        # The offset computation depends on it being an array or a struct

        # Case 1: array
        # In this case, we simply multiply the value of the expression by the
        # array type size and add it to the variable base address.
        if isinstance(self.element, VAR):
            (
                element_code,
                register,
                environment
            ) = self.element.generate_code(
                register=register,
                environment=environment
            )
            element_value_register = register - 1

            code.extend([
                *element_code,

                # Load the variable size into a register
                {
                    "instruction": "CONSTANT",
                    "metadata": {
                        "register": register,
                        "value": builtin_types.get(self.variable.get_type()),
                    }
                },

                # Compute the offset
                {
                    "instruction": "MULT",
                    "metadata": {
                        "register": register + 1,
                        "lhs_register": element_value_register,
                        "rhs_register": register
                    }
                }
            ])

            register += 2

        # Case 2: struct
        # In this case, the compiler already knows the offset. As such, 
        else:
            code.append({
                "instruction": "CONSTANT",
                "metadata": {
                    "register": register,
                    "value": self._compute_element_offset(),
                }
            })

            register += 1

        code.append(
            {
                "instruction": "ADD",
                "metadata": {
                    "register": register,
                    "lhs_register": variable_address_register,
                    "rhs_register": register - 1
                }
            }
        )

        register += 1

        if self.context.get("context") == "read":
            code.append({
                "instruction": "LOADF" if self.type == "float" else "LOAD",
                "metadata": {"register": register, "value": register - 1}
            })

            register += 1

        return code, register, environment


    @override
    def certificate(
        self,
        positional_prime: int,
        certificator_env: dict[int, list[int]]
    ) -> tuple[int, dict[int, list[int]]]:
        """
        Compute the certificate of the current `ELEMENT_ACCESS`, and set this attribute.

        For `ELEMENT_ACCESS` nodes, the certificate is composed by the symbol
        associated to the instruction being used (VALUE or ADDRESS) together
        with the `prime` of the variable being accessed and a composition of
        access type and offset.

        If statically accessed, the composition will be `2^(offset + 1)`. The +1
        is to avoid `0` exponents. This is the case for arrays indexed by a
        constant, or access to struct attributes.

        If dynamically accessed, the composition will be `3^(prime of the
        indexing variable)`. This is the case for arrays indexed by a variable.

        Parameters
        ----------
        positional_prime : int
            A prime number that denotes the relative position of this node in
            the source code.
        certificator_env : dict[int, list[int]]
            The certificators's environment, that maps variables IDs to
            encodings of their types.

        Returns
        -------
        : int
            The prime that comes immediately after `positional_prime`.
        certificator_env : dict[int, list[int]]
            The updated certificator's environment, with any additional
            information about the variable's types it might have captured.
        """

        certificate_label = f"({self.symbol})"

        # Add the prime of the variable being accessed
        variable_metadata = self.variable.get_metadata()
        variable_prime = variable_metadata["prime"]
        certificate_label += f"^({variable_prime})"

        # Static access (i.e., indexing an array with a variable, or accessing
        # a struct attribute)
        if isinstance(self.element, CST):
            offset_size = self.element.get_value()
            certificate_label += f"^(2)^({offset_size + 1})"

            # Update the environment with the symbol of the accessed element's
            # type
            accessed_attribute_index: int = self.element.get_value()
            certificator_env[variable_prime][accessed_attribute_index] = (
                TYPE_SYMBOLS_MAP[self.type]["type_symbol"]
            )

        else:
            indexing_variable_metadata = self.element.get_metadata()
            indexing_variable_prime = indexing_variable_metadata["prime"]
            certificate_label += f"^(3)^({indexing_variable_prime})"

        self.certificate_label = f"{positional_prime}^({certificate_label})"

        return next_prime(positional_prime), certificator_env

    def add_context(self, context: dict[str, str]) -> None:
        """
        Add context to this `ELEMENT_ACCESS` node.

        The context indicates whether this variable is being readed or written.

        Parameters
        ----------
        context : dict[str, str]
            The context of this variable use.
        """

        self.context = context

        _context: str = context.get("context", "read")
        symbol: str = ""

        if _context == "read":
            symbol = get_certificate_symbol("VAR_VALUE")

        else:
            symbol = get_certificate_symbol("VAR_ADDRESS")

        self.symbol = symbol

        # Propagate context to the variable
        self.variable.add_context(context)

    def _compute_element_type(self) -> str:
        """
        Compute the type of this `ELEMENT_ACCESS`.

        The type of this Node is the type of the element being accessed as
        declared in its `variable_metadata`.

        Returns
        -------
        : str
            The type of the accessed element.
        """

        variable_metadata = self.variable.get_metadata()
        variable_type: str = variable_metadata["type"]

        # If the type of the struct-like variable is a built-in, then it is an
        # array of such type.
        if variable_type in TYPE_SYMBOLS_MAP:
            return variable_type

        # If not, then it is a user-defined struct. Thus, get the type of the
        # element being accessed.
        struct_attributes = variable_metadata["attributes"]
        accessed_attribute_index: int = self.element.get_value()
        accessed_attribute_name: str = list(struct_attributes)[accessed_attribute_index]
        accessed_attribute_type: str = struct_attributes[accessed_attribute_name][
            "type"
        ]

        return accessed_attribute_type

    def _compute_element_offset(self) -> int:
        """
        Compute the number of bytes to offset to reach the accessed element.

        This method only handles structs.

        Returns
        -------
        offset_size : int
            The size, in bytes, of the element offset.
        """

        variable_metadata: dict = self.variable.get_metadata()
        variable_attributes: dict = variable_metadata.get("attributes")

        offset_size: int = 0

        # Struct
        if variable_attributes is not None:
            # Iterate over the attributes and sum the offset, in bytes, until
            # the `element` is found
            for attribute_metadata in variable_attributes.values():
                attribute_position: int = attribute_metadata.get("attr_pointer")

                if attribute_position == self.element.get_value():
                    break

                attribute_type: str = attribute_metadata.get("type")
                attribute_size: int = builtin_types.get(attribute_type)

                offset_size += attribute_size

        # Array
        else:
            var_type = self.variable.get_type()
            offset_size = self.element.get_value() * builtin_types.get(var_type)

        return offset_size

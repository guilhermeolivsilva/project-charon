"""Representation of STRUCT_DEF nodes for the Abstract Syntax Tree."""

from typing import Union

from typing_extensions import override

from src.ast_nodes.certificate_mapping import TYPE_SYMBOLS_MAP
from src.ast_nodes.node import Node


class STRUCT_DEF(Node):
    """
    Implement the representation of a struct definition for the AST.

    Parameters
    ----------
    struct_metadata : dict
        Dictionary of struct metadata exported by the Lexer.
    """

    @override
    def __init__(self, struct_metadata: dict[str, dict[str, dict]]) -> None:
        relative_position: int = struct_metadata.get("relative_position")
        _type: str = struct_metadata.get("type")

        super().__init__(relative_position, type=_type)

        self.active: bool = struct_metadata.get("active")
        self.struct_metadata = struct_metadata
        self.symbol: str = self._compute_symbol()

    @override
    def print(self, indent: int = 0) -> None:
        """
        Print the string representation of this `STRUCT_DEF`.

        The node itself is aligned with `indent`, and the information about its
        attributes is padded with an additional left space.

        Parameters
        ----------
        indent : int (optional, default = 0)
            The number of left padding spaces to indent.
        """

        super().print(indent)

        _attribute_types = ", ".join(self.get_attribute_types())

        print(f"{' ' * (indent + 1)} Attributes: {_attribute_types}")

    @override
    def certificate(self, prime: int) -> int:
        """
        Compute the certificate of this `STRUCT_DEF`.

        For `STRUCT_DEF` nodes, the certificate is simply the `symbol` set
        during the object initialization.

        This method does not manipulate the `prime` parameter, as the notion of
        relative position of this `STRUCT_DEF` in the code is already obtained
        from the `struct_metadata`. Thus, it returns the same given `prime`.

        Parameters
        ----------
        prime : int
            A prime number that represents the relative position of the `Node`
            in the AST.

        Returns
        -------
        : int
            A prime number that comes after the given `prime`.
        """

        return prime

    @override
    def generate_code(self, register: int) -> tuple[
        int,
        list[dict[str, Union[int, str]]]
    ]:
        """
        Generate the code associated with this `STRUCT_DEF`.

        For this node specialization, there is no code to be generated -- the
        struct definition is just an abstraction. Still, it takes a `register`
        as parameter, but returns it without incrementing it.

        Parameters
        ----------
        register : int
            The number of the register to be used by the code generated by this
            Node.

        Returns
        -------
        register : int
            The same given `register`.
        code_metadata : list
            An empty list.
        """

        return register, []

    def get_symbol(self) -> str:
        """
        Get the `symbol` attribute from this `STRUCT_DEF`.

        Returns
        -------
        : str
            The `symbol` attribute.
        """

        return self.symbol
    
    def get_attribute_types(self) -> list[str]:
        """
        Get the types of the attributes of this struct.

        The types are returned in the same order as they have been declared in
        the struct definition.

        Returns
        -------
        attribute_types : list[str]
            A list containing the attributes types.
        """

        attribute_types: list[str] = [
            attribute.get("type")
            for attribute in self.struct_metadata.get("attributes").values()
        ]

        return attribute_types
    
    def is_active(self) -> bool:
        """
        Tell whether this struct definition is `active` or not.

        A struct is `active` if at least one variable of its type has been
        defined in the source code.

        Returns
        -------
        active : bool
            Wheter the struct is active or not.
        """

        return self.active
    
    def _compute_symbol(self) -> str:
        """
        Compute the symbol of this struct.

        The symbol is a string, created by joining subsequent exponentiations
        ("^") of each of the attributes' type.

        Returns
        -------
        attributes_symbol : str
            The symbol of this struct.
        """

        attributes_symbol: str = "^".join(
            f"({TYPE_SYMBOLS_MAP[attribute['type']]['type_symbol']})"
            for attribute in self.struct_metadata["attributes"].values()
        )

        return attributes_symbol

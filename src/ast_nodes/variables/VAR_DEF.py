"""Representation of VAR_DEF nodes for the Abstract Syntax Tree."""

from typing import Union

from typing_extensions import override

from src.ast_nodes.node import Node


class VAR_DEF(Node):
    """
    Implement the representation of a variable definition for the AST.

    Parameters
    ----------
    id : int
        The ID of the Node.
    variable_metadata : dict
        Dictionary of variable metadata exported by the Lexer.
    """

    @override
    def __init__(self, id: int, variable_metadata: dict) -> None:

        relative_position: int = variable_metadata.get("relative_position")
        type: str = variable_metadata.get("type")

        super().__init__(id, relative_position, type, uses_register=False)

        self.variable_metadata: dict = variable_metadata
        self.instruction: str = "ALLOC"

        # The `type_certificate` is a placeholder! The `frontend` certificator
        # is responsible for filling it later.
        prime: int = variable_metadata["prime"]
        self.symbol: str = (
            f"({self.symbol})^"
            + f"({prime})^"
            + f"({type}_certificate)"
        )

        _length = self.variable_metadata.get("length")
        if _length:
            self.symbol += f"^({_length})"

    @override
    def print(self, indent: int = 0) -> None:
        """
        Print the string representation of this `VAR_DEF`.

        The node itself is aligned with `indent`, and the information about its
        attributes is padded with an additional left space.

        Parameters
        ----------
        indent : int (optional, default = 0)
            The number of left padding spaces to indent.
        """

        super().print(indent)

        var_def_metadata: str = f"Name: {self.variable_metadata.get('name')}, "
        var_def_metadata += f"Type: {self.variable_metadata.get('type')}"

        if self.variable_metadata.get("length"):
            var_def_metadata += f" (array), Length: {self.variable_metadata.get('length')}"

        print(f"{'  ' * (indent + 1)}{var_def_metadata}")

    @override
    def generate_code(self, register: int) -> tuple[
        int,
        list[dict[str, Union[int, str]]]
    ]:
        """
        Generate the code associated with this `VAR_DEF`.

        For this node specialization, the generated code is an `ALLOC`
        instruction. The bytecode contains information about the type, and
        length, if it is an array.

        Parameters
        ----------
        register : int
            The number of the register to be used by the code generated by this
            Node.

        Returns
        -------
        register : int
            The number of the next register available.
        code_metadata : list of dict
            Return a list of dictionaries containing code metadata: the related
            `instruction`, and node `id`, and `value`.
        """

        code_metadata: list[dict[str, Union[int, str]]] = []

        var_def_code = {
            "instruction": self.instruction,
            "metadata": {
                "id": self.id,
                "type": self.type,
                "relative_position": self.value,
                "length": self.variable_metadata.get("length", 1)
            }
        }

        code_metadata.append(var_def_code)

        return register, code_metadata
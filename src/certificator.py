"""
Annotate statements and instructions with unique IDs.

Statements and instructions that implement the same semantics must have the
same ID. However, no pair of statements must have the same ID -- and the same
goes for instructions.
"""

from src.lexer import Lexer


def generate_primes(number_of_primes: int) -> list[int]:
    """
    Generate a list with the first `number_of_primes`-th prime numbers.

    This function uses D. Eppstein's implementation of the Sieve of
    Eratosthenes to achieve its goal.

    Parameters
    ----------
    number_of_primes : int
        The amount of prime numbers to generate.

    Returns
    -------
    primes : list[int]
        List with the first `number_of_primes` prime numbers.
    """

    primes = []

    cache = {}
    current_integer = 2

    while len(primes) <= number_of_primes:
        if current_integer not in cache:
            primes.append(current_integer)
            cache[current_integer * current_integer] = [current_integer]
        else:
            for cached_element in cache[current_integer]:
                cache.setdefault(cached_element + current_integer, []).append(
                    cached_element
                )
            del cache[current_integer]

        current_integer += 1

    return primes


class Certificator:
    """
    Certificator that attests whether a frontend source code is correctly
    implemented by its corresponding backend code.

    This Certificator generates unique IDs for each instruction using Gödel's
    numbering system for both the frontend and backend codes. If the generated
    representations match, then the backend correctly implements the frontend.

    Parameters
    ----------
    frontend_code : list[tuple]
        A list of tuples of the parsed frontend source code generated by the
        Tiny-C Lexer.
    backend_code : list[tuple]
        A list of tuples of the backend source code generated by the Tiny-C
        Code Generator.
    """

    def __init__(self, frontend_code: list[tuple], backend_code: list[tuple]) -> None:
        self.frontend_code = frontend_code
        self.backend_code = backend_code

        supported_tokens = Lexer.get_supported_tokens()
        self.frontend_tokens = {
            key: value
            for key, value in zip(
                supported_tokens, generate_primes(len(supported_tokens))
            )
        }

    def parse_frontend_code(self) -> str:
        """
        Generate a string representation of the frontend code.

        Returns
        -------
        representation : str
            A unique string representation of the frontend code.
        """        

        frontend_handlers_map = {
            "ID": self._parse_frontend_variable,
            "INT": self._parse_frontend_integer
        }

        primes = generate_primes(len(self.frontend_code))

        representation = ""

        for code, prime in zip(self.frontend_code, primes):
            code_kind, _ = code

            handler = frontend_handlers_map.get(
                code_kind,
                self._parse_frontend_default
            )

            representation += handler(code=code, prime=prime)

        # Pad out the " * " at the end of the string.
        representation = representation[:-3]

        return representation
    
    def _parse_frontend_default(self, code: tuple[str], prime: int) -> str:
        """
        Parse a symbol or a reserved word from the frontend.

        This is the default parser -- i.e., parses any tokens unless it's an
        integer or a variable.

        Parameters
        ----------
        code : tuple[str]
            Tuple that represents a single code piece from the frontend source
            code. This is a pair of (`token`, `value`).
        prime : int
            A prime number to identify this code piece.

        Returns
        -------
         : str
            The parsed representation
        """

        # The associated `value` of these tokens is always `None`.
        token, _ = code

        return f"({self.frontend_tokens.get(token)}^{prime}) * "


    def _parse_frontend_variable(self, code: tuple[str], prime: int) -> str:
        """
        Parse a variable from the frontend source code.

        Parameters
        ----------
        code : tuple[str]
            Tuple that represents a single code piece from the frontend source
            code. This is a pair of (`token`, `value`).
        prime : int
            A prime number to identify this code piece.

        Returns
        -------
        representation : str
            The parsed representation
        """

        # To parse a variable, we only need its name.
        _, variable_name = code

        return f"({self.frontend_tokens.get(variable_name)}^{prime}) * "
    
    def _parse_frontend_integer(self, code: tuple[str], prime: int) -> str:
        """
        Parse a literal integer from the frontend source code.

        Parameters
        ----------
        code : tuple[str]
            Tuple that represents a single code piece from the frontend source
            code. This is a pair of (`token`, `value`).
        prime : int
            A prime number to identify this code piece.

        Returns
        -------
        representation : str
            The parsed representation
        
        TODO: review Gödel's numbering for constants.
        """

        token, value = code

        return f"({value}*{self.frontend_tokens.get(token)}^{prime}) * "

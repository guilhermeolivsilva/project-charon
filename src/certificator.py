"""
Annotate statements and instructions with unique IDs.

Statements and instructions that implement the same semantics must have the
same ID. However, no pair of statements must have the same ID -- and the same
goes for instructions.
"""

from string import ascii_lowercase

from src.abstract_syntax_tree import AbstractSyntaxTree
from src.code_generator import CodeGenerator
from src.node import Node


def is_prime(number: int) -> bool:
    """
    Check whether the given `number` is a prime.

    Parameters
    ----------
    number : int
        The number to test.

    Returns
    -------
    : bool
        The verdict.
    """

    if number < 2:
        return False

    for i in range(2, int(number ** 0.5) + 1):
        if number % i == 0:
            return False

    return True


def next_prime(number: int) -> int:
    """
    Compute the next prime immediately after `number`.

    Parameters
    ----------
    number : int
        The reference number.

    Returns
    -------
    next_number : int
        The first prime after `number`.
    """

    next_number = number + 1

    while True:
        if is_prime(next_number):
            return next_number

        next_number += 1


class Certificator:
    """
    Certificator that attests whether a frontend source code is correctly
    implemented by its corresponding backend code.

    This Certificator generates unique IDs for each instruction using GÃ¶del's
    numberbering system for both the frontend and backend codes. If the generated
    representations match, then the backend correctly implements the frontend.

    Parameters
    ----------
    frontend_code : AbstractSyntaxTree
        The Abstract Syntax Tree that represents the frontend code.
    backend_code : list[tuple]
        A list of tuples of the backend source code generated by the Tiny-C
        Code Generator.
    """

    variables = ascii_lowercase
    literals = [str(literal) for literal in range(0, 10)]

    frontend_symbols = [
        *AbstractSyntaxTree.node_kinds,
        *variables,
        *literals
    ]

    backend_symbols = [
        *CodeGenerator.instructions,
        *variables,
        *literals
    ]

    def __init__(
        self, frontend_code: AbstractSyntaxTree, backend_code: list[tuple]
    ) -> None:
        self.frontend_code = frontend_code
        self.backend_code = backend_code

        self.frontend_tokens = {
            key: value
            for key, value in zip(
                self.frontend_symbols,
                range(1, len(self.frontend_symbols) + 1)
            )
        }

        self.backend_tokens = {
            key: value
            for key, value in zip(
                self.backend_symbols,
                range(1, len(self.backend_symbols) + 1)
            )
        }

    def traverse_ast(self):
        """Traverse the AST and annotate each node with its relative position."""

        # Using a list to avoid issues with variable scoping in nested function
        base = [1]

        def traverse(node: Node) -> None:
            if node is None:
                return

            for child in node.children:
                traverse(child)

            base[0] = next_prime(base[0])
            exponent = self.get_label_exponent(node)

            certificate_label = f"{base[0]}^{exponent}"

            node.set_certificate_label(certificate_label)

        traverse(self.frontend_code)

    def get_label_exponent(self, node: Node) -> str:
        """
        Compute the exponent to label the given `node`.

        Parameters
        ----------
        node : Node
            The AST node to compute its associated exponent.

        Returns
        -------
        : str
            The unique exponent to label the `node`.
        """

        node_handlers = {
            "VAR": self._get_value_exponent,
            "CST": self._get_value_exponent,
            "ADD": self._get_keyword_exponent,
            "SUB": self._get_keyword_exponent,
            "LT": self._get_keyword_exponent,
            "EXPR": self._get_keyword_exponent,
            "PROG": self._get_keyword_exponent,
            "EMPTY": self._get_keyword_exponent,
            "SET": self._get_set_exponent,
            "IF": self._get_keyword_exponent,
            "IFELSE": self._get_keyword_exponent,
            "WHILE": self._get_keyword_exponent,
            "DO": self._get_keyword_exponent,
            "SEQ": self._get_keyword_exponent,
        }

        handler = node_handlers.get(node.kind)

        return handler(node=node)
    
    def _get_value_exponent(self, node: Node) -> str:
        """
        Parse a VAR or CST Node.

        Parameters
        ----------
        node : Node
            The Node to compute the exponent for.

        Returns
        -------
        : str
            The exponent associated to the `node`.
        """

        # TODO: parse integers digit by digit

        return self.frontend_tokens.get(str(node.value))

    def _get_keyword_exponent(self, node: Node) -> str:
        """
        Parse a keyword Node.

        A keyword Node is a node whose `kind` is Tiny C reserved word or an
        operator (+, -, <).

        Parameters
        ----------
        node : Node
            The Node to compute the exponent for.

        Returns
        -------
        : str
            The exponent associated to the `node`.
        """

        return self.frontend_tokens.get(node.kind)

    def _get_set_exponent(self, node: Node) -> str:
        """
        Parse a SET Node.

        Parameters
        ----------
        node : Node
            The Node to compute the exponent for.

        Returns
        -------
        : str
            The exponent associated to the `node`.
        """

        exponent = (
            100 * self.frontend_tokens.get(node.kind) +
            self.frontend_tokens.get(node.value)
        )

        return str(exponent)
